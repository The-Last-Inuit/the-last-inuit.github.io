

    ← back

    Layoffs
    Dec 19, 2025

    Today I have an interview. I was expecting to look for a job in a few years,
    but sadly, layoffs started happening at my current company. There have been
    two waves already. It was supposed to be over, but it got me thinking: maybe
    it's time to move on. So I started interviewing. The current climate isn't
    great, but well... I have to.
    Today's interview was for a company that uses Go. I played with Go a long time
    ago, and nothing since then. Still, it's just a language. One of the nice
    things about getting older (and hopefully wiser) is realizing that languages
    are just tools. As long as you understand algorithms, design approaches, and
    so on, the language isn't a barrier or at least, that's what I believe.
    Anyway, I picked up Go again to prepare for the next interview, which will
    happen next year. It's kind of weird, since it'll be an interview with seven
    software engineers. I don't feel pressure, but... it's weird.
    Anyhow, I really love how Elixir handles asynchronous tasks. Revisiting Go
    reminded me why I find it a bit off-putting.
    Here's what I've learned.
    Go vs Elixir
    This is a practical comparison of how Go and Elixir (BEAM/OTP) approach
    doing many things at once: concurrent I/O, background jobs, fan-out/fan-in
    pipelines, and fault-tolerant workers.

    Terminology note: both ecosystems often say concurrency rather than
    asynchronous. In practice, async tasks usually means run work concurrently
    without blocking the caller.

    TL;DR

    Go: you build concurrency explicitly with goroutines + channels (and
    context for cancellation). You also build your own supervision patterns
    (restart, isolation, backoff) or use libraries.
    Elixir: the runtime is built around isolated lightweight processes +
    message passing + OTP supervision. Starting concurrent work is easy, and
    restarts/fault-handling are first-class.

    Both can be excellent, they just optimize for different defaults.
    Core mental model
    Go

    Concurrency primitive: goroutine (cheap thread-like unit).
    Communication: channels (typed queues) or shared memory with locks.
    Failure model: panics exist, but errors are usually returned,
    goroutine crashes don't automatically restart.
    You typically implement:

    cancellation via context.Context
    structured concurrency via errgroup
    restart/backoff via your own loops or orchestration (systemd/K8s)



    Elixir (BEAM/OTP)

    Concurrency primitive: process (even cheaper, isolated, preemptively
    scheduled).
    Communication: message passing (send/2, receive), mailboxes.
    Failure model: “let it crash” + supervisors restart children.
    Structured concurrency & lifecycle are built into OTP:

    Supervisor, Task.Supervisor, GenServer, GenStage, Broadway



    Side-by-side mapping
    Goal
