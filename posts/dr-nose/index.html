<!DOCTYPE html>

<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="color-scheme" content="light dark">
  
  
    
  
  <meta name="description" content="Software engineering à la Mexicana">

  <title>Dr. Nose | updates</title>
  <link rel="icon" type="image/png" sizes="32x32" href="https://idunnowhatiamdoing.engineering/img/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://idunnowhatiamdoing.engineering/img/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://idunnowhatiamdoing.engineering/img/apple-touch-icon.png">
  
  <style>
  @import url("https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap");

  :root {
    --bg-top: #ffffff;
    --bg-bottom: #ffffff;
    --ink: #141414;
    --muted: #6a6358;
    --link: #1d4f8c;
    --max: 81ch;
    --pad: clamp(1rem, 3vw, 2.5rem);
  }

  * {
    box-sizing: border-box;
  }

  html {
    font-size: 100%;
  }

  body {
    margin: 0;
    min-height: 100%;
    padding: var(--pad);
    background: linear-gradient(180deg, var(--bg-top), var(--bg-bottom));
    color: var(--ink);
    font-family: "Share Tech Mono", monospace;
    font-size: 16px;
    line-height: 1.5;
    text-rendering: optimizeLegibility;
    -webkit-font-smoothing: antialiased;
  }

  main.txt {
    max-width: var(--max);
    margin: 0 auto;
  }

  pre {
    font-family: "Share Tech Mono", monospace;
  }
  pre.txt-block {
    margin: 0;
    white-space: pre;
    overflow-x: auto;
  }

  a {
    color: inherit;
    text-decoration: underline;
    text-decoration-style: dotted;
    text-decoration-thickness: 1px;
    text-underline-offset: 2px;
  }

  a:visited {
    color: inherit;
  }

  a:where(:hover, :focus) {
    color: var(--link);
  }

  ::selection {
    background: rgba(29, 79, 140, 0.18);
  }
  p {
    margin: 0;
    line-height: 16pt;
  }
  ul,
  ol {
    margin: 0;
    line-height: 10pt;
  }
  li {
    line-height: 16pt;
  }
  blockquote {
    margin: 0 16pt;
    line-height: 16pt;
  }
  img {
    max-width: 64ch;
  }
  @media (prefers-reduced-motion: no-preference) {
    main.txt {
      animation: fade-in 600ms ease-out both;
    }

    @keyframes fade-in {
      from {
        opacity: 0;
        transform: translateY(6px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
  }

  @media (max-width: 700px) {
    body {
      font-size: 15px;
      padding: 1rem;
    }
    pre.txt-block {
      white-space: pre-wrap;
    }
    pre code {
      text-wrap: auto;
    }
  }
</style>

  

<link id="hl" rel="stylesheet" type="text/css" href="/hl-light.css" />



  
</head>

<body class="post">
  
  
<main class="txt">
  <pre class="txt-block">

<a id="back-link" href="/">← back</a>

<b>Dr. Nose | updates</b>
<span id="publish">Jan 22, 2026</span>

<p><img src="/img/dr-nose.png" alt="dr-nose" /></p>
<p>Wi-Fi recon is mostly about observation: detect beacons, learn BSSIDs,
map channels, and track signal behavior over time. Dr. Nose is a small
Rust app that stays strictly passive while giving you an
operator-friendly view of 802.11 captures. It reads monitor-mode
PCAPs (radiotap + 802.11), aggregates access points, and lets you save
and export frames for deeper analysis.</p>
<p><strong>Data flow overview</strong></p>
<p>Dr. Nose runs a decode loop in a background thread:</p>
<ol>
<li>Read packets from a PCAP file.</li>
<li>Decode radiotap (RSSI, channel MHz) and 802.11 headers.</li>
<li>Build a frame summary for UI and aggregation.</li>
<li>Optionally save a selected frame to SQLite for later export.</li>
</ol>
<p>The UI shows a live timeline and a rolling AP list. It never transmits
or injects; it's read-only on captures.</p>
<p><strong>Radiotap and 802.11 decoding</strong></p>
<p>The decoder handles two linktypes:</p>
<ul>
<li><code>LINKTYPE_IEEE802_11</code> (105)</li>
<li><code>LINKTYPE_IEEE802_11_RADIOTAP</code> (127)</li>
</ul>
<p>Radiotap parsing is intentionally minimal. It extracts only:</p>
<ul>
<li>Channel frequency in MHz</li>
<li>Antenna signal in dBm</li>
</ul>
<p>802.11 header parsing is "MVP-correct" for management and data frames.
It parses frame control fields, addresses, and subtype, and then infers
BSSID using the DS flags.</p>
<p>This is enough to support most recon tasks:</p>
<ul>
<li>Identify BSSID and SSID associations.</li>
<li>Track channel usage per AP.</li>
<li>Watch signal strength shifts over time.</li>
</ul>
<p><strong>Live tailing a growing PCAP</strong></p>
<p>On macOS, Wireless Diagnostics Sniffer writes to <code>/var/tmp/*.pcap</code>.
Dr. Nose can tail a growing capture by periodically reopening the file
and advancing to the last processed index.</p>
<p>The loop pattern is:</p>
<pre class="z-code"><code><span class="z-text z-plain">open pcap
</span><span class="z-text z-plain">skip N packets already seen
</span><span class="z-text z-plain">read new packets until EOF
</span><span class="z-text z-plain">sleep briefly and repeat
</span></code></pre>
<p>This is safe, simple, and good enough for a live feed. It avoids
external dependencies and works with long-running captures while
staying passive.</p>
<p><strong>Aggregation and memory hygiene</strong></p>
<p>For operational clarity, the app keeps two rolling data structures:</p>
<ul>
<li>A timeline of recent frames (bounded by <code>MAX_TIMELINE</code>).</li>
<li>An AP map keyed by BSSID (bounded by <code>MAX_APS</code>).</li>
</ul>
<p>AP pruning is LRU-like, based on the last seen timestamp. This
prevents unbounded memory use when capturing in dense RF
environments.</p>
<p><strong>Persistence and export</strong></p>
<p>Saved frames go into SQLite with metadata plus raw bytes. The
schema includes:</p>
<ul>
<li><code>dot11_type</code>, <code>dot11_subtype</code></li>
<li><code>bssid</code>, <code>ssid</code></li>
<li><code>channel_mhz</code>, <code>rssi_dbm</code></li>
<li><code>addr1</code>, <code>addr2</code>, <code>addr3</code></li>
<li><code>linktype</code></li>
<li><code>frame_blob</code></li>
</ul>
<p>Exports are supported for:</p>
<ul>
<li>PCAP: rehydrates <code>frame_blob</code> with stored timestamps and
linktype.</li>
<li>CSV/JSON: metadata-focused for quick analysis pipelines.</li>
</ul>
<p>This setup works well for triage and later deep dives:</p>
<ul>
<li>Import PCAP into Wireshark</li>
<li>Pipe CSV into a recon notebook</li>
<li>Run JSON through custom automation</li>
</ul>
<p><strong>Filtering and frame inspection</strong></p>
<p>The UI includes filters for BSSID, SSID, channel, and frame
type. Matching happens in-app without database queries.</p>
<p>Inspect mode surfaces:</p>
<ul>
<li>Type and subtype labels</li>
<li>BSSID, SSID, addresses</li>
<li>Channel and RSSI</li>
<li>Linktype and raw frame length</li>
</ul>
<p>This makes it easy to spot patterns like:</p>
<ul>
<li>Probe storms from a single client</li>
<li>Rogue AP beacons on unexpected channels</li>
<li>RSSI shifts that suggest AP movement or spoofing</li>
</ul>
<p><strong>Testing the decoder</strong></p>
<p>Unit tests cover:</p>
<ul>
<li>SSID and DS channel IE parsing</li>
<li>802.11 header parsing and BSSID inference</li>
<li>Radiotap fields (channel, RSSI)</li>
</ul>
<p>Tiny synthetic fixtures are enough to lock in parsing
behavior without large PCAP fixtures in the repo.</p>
<p><strong>Operational guidance</strong></p>
<p>Dr. Nose is designed for ethical recon and troubleshooting:</p>
<ul>
<li>Validate AP behavior in your own environment</li>
<li>Verify capture quality and channel coverage</li>
<li>Archive evidence for incident response</li>
</ul>
<p>Always ensure you have authorization for the airspace you
are monitoring. Passive observation can still fall under
regulatory and organizational rules.</p>

  </pre>
</main>

  
<script src="/js/lightense.min.js"></script>

  <script src="https://idunnowhatiamdoing.engineering/js/main.js"></script>
</body>

</html>
