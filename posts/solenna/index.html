<!DOCTYPE html>

<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="color-scheme" content="light dark">
  
  
    
  
  <meta name="description" content="Software engineering à la Mexicana">

  <title>solënna</title>
  <link rel="icon" type="image/png" sizes="32x32" href="https://idunnowhatiamdoing.engineering/img/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://idunnowhatiamdoing.engineering/img/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://idunnowhatiamdoing.engineering/img/apple-touch-icon.png">
  
  <style>
  @import url("https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap");

  :root {
    --bg-top: #ffffff;
    --bg-bottom: #ffffff;
    --ink: #141414;
    --muted: #6a6358;
    --link: #1d4f8c;
    --max: 81ch;
    --pad: clamp(1rem, 3vw, 2.5rem);
  }

  * {
    box-sizing: border-box;
  }

  html {
    font-size: 100%;
  }

  body {
    margin: 0;
    min-height: 100%;
    padding: var(--pad);
    background: linear-gradient(180deg, var(--bg-top), var(--bg-bottom));
    color: var(--ink);
    font-family: "Share Tech Mono", monospace;
    font-size: 16px;
    line-height: 1.5;
    text-rendering: optimizeLegibility;
    -webkit-font-smoothing: antialiased;
  }

  main.txt {
    max-width: var(--max);
    margin: 0 auto;
  }

  pre {
    font-family: "Share Tech Mono", monospace;
  }
  pre.txt-block {
    margin: 0;
    white-space: pre;
    overflow-x: auto;
  }

  a {
    color: inherit;
    text-decoration: underline;
    text-decoration-style: dotted;
    text-decoration-thickness: 1px;
    text-underline-offset: 2px;
  }

  a:visited {
    color: inherit;
  }

  a:where(:hover, :focus) {
    color: var(--link);
  }

  ::selection {
    background: rgba(29, 79, 140, 0.18);
  }
  p {
    margin: 0;
    line-height: 16pt;
  }
  ul,
  ol {
    margin: 0;
    line-height: 10pt;
  }
  li {
    line-height: 16pt;
  }
  blockquote {
    margin: 0 16pt;
    line-height: 16pt;
  }
  img {
    max-width: 64ch;
  }
  @media (prefers-reduced-motion: no-preference) {
    main.txt {
      animation: fade-in 600ms ease-out both;
    }

    @keyframes fade-in {
      from {
        opacity: 0;
        transform: translateY(6px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
  }

  @media (max-width: 700px) {
    body {
      font-size: 15px;
      padding: 1rem;
    }
    pre.txt-block {
      white-space: pre-wrap;
    }
    pre code {
      text-wrap: auto;
    }
  }
</style>

  

<link id="hl" rel="stylesheet" type="text/css" href="/hl-light.css" />



  
</head>

<body class="post">
  
  
<main class="txt">
  <pre class="txt-block">

<a id="back-link" href="/">← back</a>

<b>solënna</b>
<span id="publish">Jan 14, 2026</span>

<p><img src="/img/sol%C3%ABnna.png" alt="solënna" /></p>
<p><strong>solënna: building a compact libp2p node for geotagged data</strong></p>
<p>Here is a quick tour of the engineering choices behind solënna, a small
libp2p node that publishes and browses signed, geotagged datapoints. My
goals were simple: keep the stack small, ship a usable UI fast, and still
survive on a public network without turning into a spam magnet.</p>
<p><strong>Problem framing</strong></p>
<p>Location-based systems tend to be either centralized and easy, or
decentralized and hard to operate. I wanted a node that felt like a single
binary you can run on a laptop, but that still federates into a public P2P
network without needing a dedicated ops stack. That led me to a few
constraints:</p>
<ul>
<li>Storage needed to be local and simple.</li>
<li>The UI had to ship with the node.</li>
<li>The protocol had to verify authorship without central authority.</li>
<li>The network had to defend itself from trivial write abuse.</li>
</ul>
<p><strong>Architecture overview</strong></p>
<p>At a high level, the node is a libp2p swarm loop plus a local SQLite store
and an HTTP server. The <a rel="nofollow noreferrer" href="https://app.radicle.xyz/nodes/seed.radicle.garden/rad:zhzsX3bknxQhN6wbTY2QoxPhGbzp">repo</a> mirrors that split:</p>
<ul>
<li><code>src/main.rs</code> is the swarm loop and CLI wiring.</li>
<li><code>src/protocol.rs</code> defines the signed object format and request/response types.</li>
<li><code>src/store.rs</code> implements persistence and geohash indexing.</li>
<li><code>src/http.rs</code> hosts both the LiveView UI and a JSON API.</li>
</ul>
<p>Keeping it this way means one process, one data directory, and a much simpler
mental model when you are debugging or deploying.</p>
<p><strong>Data model: signed objects with location metadata</strong></p>
<p>I went with content-addressed objects that are signed by an author keypair.
That gives me a few nice properties:</p>
<ul>
<li>IDs are derived from content, so the same object is globally stable.</li>
<li>Signatures are verified at ingest, so provenance is embedded in the data itself.</li>
<li>Objects can be replicated without a centralized database.</li>
</ul>
<p>For the UI and API, the core field is location. A point maps to a geohash cell,
which is a compact way to partition the earth into hierarchical grid buckets.</p>
<p><strong>Storage and queries: why geohash indexing works well here</strong></p>
<p>The hot path is <strong>what objects are in this viewport</strong>. I did not want to pull in a
heavy spatial index or do full-table scans with bounding boxes. Instead, the store
indexes by geohash cell. The query becomes "enumerate the geohash cells that cover
this viewport, then fetch objects per cell."</p>
<p>It is a practical tradeoff:</p>
<ul>
<li>Geohash prefix lookups are cheap in SQLite.</li>
<li>The index is stable and deterministic across nodes.</li>
<li>It keeps the API simple (<code>GET /geocell</code>, <code>GET /viewport</code>).</li>
</ul>
<p>It is not as precise as a proper spatial index, but it is more than enough for
fast, map-like browsing.</p>
<p><strong>Anti-spam: PoW + rate limits instead of trust</strong></p>
<p>Public P2P networks need backpressure. I did not want to build a full trust system,
I just wanted to make abuse expensive. solënna uses a few levers in <code>src/anti_spam.rs</code>:</p>
<ul>
<li>Proof-of-work gating for write requests.</li>
<li>Rate limits to dampen bursts.</li>
<li>Optional allowlist for closed networks.</li>
</ul>
<p>This is intentionally lightweight: it does not try to solve trust, only to make abuse
expensive enough that it is not the default behavior.</p>
<p><strong>UI in the same process: Dioxus LiveView</strong></p>
<p>The HTTP server embeds a Dioxus LiveView UI. I wanted the node to be useful immediately
after <code>cargo run</code> without a separate frontend build or extra processes. That gives you:</p>
<ul>
<li>One binary that serves both UI and JSON API.</li>
<li>Fewer deployment knobs and fewer moving parts.</li>
<li>A quick feedback loop for experimenting with protocol changes.</li>
</ul>
<p>For engineering velocity, this mattered more than having a fully decoupled
frontend.</p>
<p><strong>Real-world networking: relay support</strong></p>
<p>Most peers sit behind NAT, so Solenna ships a circuit-relay v2 binary
(<code>src/bin/solenna-relay.rs</code>) and a relay manager (<code>src/relay_mgr.rs</code>). This solves
the practical <strong>I cannot accept inbound TCP</strong> problem without needing to punch a
dozen firewall holes. It also lets you run a public relay if you want to
improve connectivity for the network.</p>
<p><strong>Operational shape</strong></p>
<p>The project is designed to deploy simply:</p>
<ul>
<li>Docker and Docker Compose for fast local runs.</li>
<li>systemd units for traditional hosts.</li>
<li>Fly.io config for quick cloud launches.</li>
</ul>
<p>The node's surface area is small: a libp2p TCP port and an HTTP port.</p>
<p><strong>What I would explore next</strong></p>
<p>A few ideas are on the roadmap:</p>
<ul>
<li>Better edit conflict resolution for high-latency networks.</li>
<li>Richer queries (tags, author trust, time windows).</li>
<li>More granular spam controls for mixed public/private clusters.</li>
</ul>
<p><strong>Closing thoughts</strong></p>
<p>solënna is intentionally small (i dislike complexity as a justification
for whatever). The goal was to prove out a minimal, usable P2P node that
handles real network constraints and still feels like a developer-friendly
tool. If you want to explore further, start in <code>src/store.rs</code> or <code>src/http.rs</code>
and keep the loop tight: change a thing, run the node, open the UI, repeat.</p>
<p>For a quick run command and endpoint list, the README has the minimal setup.</p>

  </pre>
</main>

  
<script src="/js/lightense.min.js"></script>

  <script src="https://idunnowhatiamdoing.engineering/js/main.js"></script>
</body>

</html>
