<!DOCTYPE html>

<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="color-scheme" content="light dark">
  
  
    
  
  <meta name="description" content="Software engineering à la Mexicana">

  <title>Hardware Memory</title>
  <link rel="icon" type="image/png" sizes="32x32" href="https://idunnowhatiamdoing.engineering/img/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://idunnowhatiamdoing.engineering/img/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://idunnowhatiamdoing.engineering/img/apple-touch-icon.png">
  
  <style>
  @import url("https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap");

  :root {
    --bg-top: #ffffff;
    --bg-bottom: #ffffff;
    --ink: #141414;
    --muted: #6a6358;
    --link: #1d4f8c;
    --max: 81ch;
    --pad: clamp(1rem, 3vw, 2.5rem);
  }

  * {
    box-sizing: border-box;
  }

  html {
    font-size: 100%;
  }

  body {
    margin: 0;
    min-height: 100%;
    padding: var(--pad);
    background: linear-gradient(180deg, var(--bg-top), var(--bg-bottom));
    color: var(--ink);
    font-family: "Share Tech Mono", monospace;
    font-size: 16px;
    line-height: 1.5;
    text-rendering: optimizeLegibility;
    -webkit-font-smoothing: antialiased;
  }

  main.txt {
    max-width: var(--max);
    margin: 0 auto;
  }

  pre {
    font-family: "Share Tech Mono", monospace;
  }
  pre.txt-block {
    margin: 0;
    white-space: pre;
    overflow-x: auto;
  }

  a {
    color: inherit;
    text-decoration: underline;
    text-decoration-style: dotted;
    text-decoration-thickness: 1px;
    text-underline-offset: 2px;
  }

  a:visited {
    color: inherit;
  }

  a:where(:hover, :focus) {
    color: var(--link);
  }

  ::selection {
    background: rgba(29, 79, 140, 0.18);
  }
  p {
    margin: 0;
    line-height: 16pt;
  }
  ul,
  ol {
    margin: 0;
    line-height: 10pt;
  }
  li {
    line-height: 16pt;
  }
  blockquote {
    margin: 0 16pt;
    line-height: 16pt;
  }
  img {
    max-width: 64ch;
  }
  @media (prefers-reduced-motion: no-preference) {
    main.txt {
      animation: fade-in 600ms ease-out both;
    }

    @keyframes fade-in {
      from {
        opacity: 0;
        transform: translateY(6px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
  }

  @media (max-width: 700px) {
    body {
      font-size: 15px;
      padding: 1rem;
    }
    pre.txt-block {
      white-space: pre-wrap;
    }
    pre code {
      text-wrap: auto;
    }
  }
</style>

  

<link id="hl" rel="stylesheet" type="text/css" href="/hl-light.css" />



  
</head>

<body class="post">
  
  
<main class="txt">
  <pre class="txt-block">

<a id="back-link" href="/">← back</a>

<b>Hardware Memory</b>
<span id="publish">Oct 19, 2025</span>

<p>I recently binged Halt and Catch Fire <strong>again</strong>. The episode where they
reverse-engineered the BIOS took me right back to when I'd watch my dad with
his oscilloscopes like he was doing magic from another universe.
It got me thinking about chips and memory. I took a microprocessors class in
college, it was a blast.
For the first post on my new, new, new blog, I'm starting with <a rel="nofollow noreferrer" href="https://research.swtch.com/hwmm">hardware memory</a>.</p>
<p><strong>Memory</strong></p>
<p>Rust doesn't magically remove the problem. What it <em>does</em> do is give you
unusually strong leverage: safe code is designed to avoid data races (which
Rust treats as Undefined Behavior), and when you need atomics, Rust exposes
the same fundamental ordering toolbox used by other systems languages.</p>
<p><strong>three contracts</strong>:</p>
<ul>
<li><strong>Hardware contract</strong>: what CPUs may do.</li>
<li><strong>Language contract</strong>: what the compiler may assume and reorder.</li>
<li><strong>Type contract</strong>: what Rust will (and won't) let you express safely.</li>
</ul>
<p><strong>Contract 1: Hardware does not promise as-written execution</strong></p>
<p>Russ Cox opens his hardware memory model series with the key punchline:
optimizations that were invisible in single-threaded programs become
<em>visible</em> with threads, and it depends becomes the default unless you have a
contract.</p>
<p>A classic litmus test is <strong>message passing</strong>:</p>
<blockquote>
<p>Thread 1 # Thread 2
x = 1 r1 = y
y = 1 r2 = x</p>
</blockquote>
<p>Can Thread 2 observe <code>r1 = 1</code> but <code>r2 = 0</code>?</p>
<ul>
<li>On a sequentially consistent machine: <strong>no</strong>.</li>
<li>On x86 TSO: <strong>no</strong>.</li>
<li>On weaker hardware like ARM/POWER: it can be <strong>yes</strong> without extra
barriers/fences.</li>
</ul>
<p>So even before we talk about compilers, <em>my writes become visible to other
cores in program order</em> is not a universal hardware law.
Another famous one is <strong>store buffering</strong> (a.k.a. store buffer / write queue):</p>
<blockquote>
<p>Thread 1 # Thread 2
x = 1 y = 1
r1 = y r2 = x</p>
</blockquote>
<p>Can we end with <code>r1 = 0</code> and <code>r2 = 0</code>?</p>
<ul>
<li>Sequentially consistent: <strong>no</strong>.</li>
<li>x86 TSO: <strong>yes</strong> (both stores sit in per-core buffers; both reads miss them).</li>
<li>ARM/POWER: <strong>yes</strong>.</li>
</ul>
<p>If your brain is screaming <em>but that's illegal</em>, good, your brain is sequentially
consistent. Your CPU is not required to be.</p>
<p><strong>Contract 2: The language memory model is where compilers get permission</strong></p>
<p>Even if hardware were perfectly sequentially consistent, the compiler still wants
to reorder, eliminate, and fuse loads/stores for speed. Those transformations
were <em>invisible</em> in single-threaded code. With threads, they become visible.</p>
<p>Language memory models generally converge on a pragmatic deal often summarized as:</p>
<blockquote>
<p><strong>DRF-SC</strong>: <em>Data-race-free programs behave as if sequentially consistent.</em></p>
</blockquote>
<p>Russ Cox describes that as a major goal in mainstream language memory models
(Java, C/C++, Rust, etc.).</p>
<p>But: <strong>DRF-SC is a conditional promise</strong>. If you have a data race, the language
may give you anything from <em>we define a weak-but-sane behavior</em> (Java historically
tried) to <em>the program has no defined meaning</em> (C/C++ land).
Rust lands firmly in the <em>no defined meaning</em> camp for data races.</p>
<p><strong>Contract 3: Rust's type system tries to prevent you from <em>writing</em> data races</strong></p>
<p>Rust's unsafe book states it plainly:</p>
<ul>
<li>A <strong>data race is Undefined Behavior</strong></li>
<li>And safe Rust is designed to make data races impossible to express (mostly
through ownership/borrowing; with <code>Send</code>/<code>Sync</code> controlling what can cross threads).</li>
</ul>
<p>Important nuance:</p>
<ul>
<li>Rust does <strong>not</strong> prevent <em>all</em> race conditions (logic races, lost updates,
timing bugs).</li>
<li>It targets <strong>data races</strong>: unsynchronized concurrent access where at least
one access is a write.</li>
</ul>
<p>This is why Rust concurrency often feels like:</p>
<blockquote>
<p>You don't get to share mutable stuff unless you prove how you're coordinating it.</p>
</blockquote>
<p>And the moment you <em>do</em> want to coordinate at a lower level (lock-free structures,
custom primitives), you end up using <strong>atomics</strong> (safe) or <code>unsafe</code> (very sharp).</p>
<p><strong>Rust atomics: what they are actually for</strong></p>
<p>Atomics are not <em>faster mutexes</em>. They are the <em>vocabulary</em> used to build
synchronization: the tool that creates <strong>happens-before</strong> edges and constrains
reordering.</p>
<p>Rust's atomic orderings (<code>Relaxed</code>, <code>Acquire</code>, <code>Release</code>, <code>AcqRel</code>, <code>SeqCst</code>) are
documented in <code>std::sync::atomic::Ordering</code>.
Here's the practical mental model I recommend:</p>
<p><strong><code>Relaxed</code>: atomicity without ordering</strong>
Good for counters, stats, <em>eventually consistent</em> observations.
It prevents torn reads/writes of that atomic variable, but does not promise when
other memory becomes visible.</p>
<p><strong><code>Release</code> / <code>Acquire</code>: publish–subscribe</strong></p>
<ul>
<li>Writer: do regular work, then <strong>Release-store</strong> a flag.</li>
<li>Reader: <strong>Acquire-load</strong> the flag, then it can safely observe what was published.</li>
</ul>
<p>Rust docs describe <code>Release</code> as making prior operations ordered before an <code>Acquire</code>
load that observes that value.</p>
<p><strong><code>SeqCst</code>: the <em>everyone agrees</em> mode</strong></p>
<p>Same synchronization power as Acquire/Release, plus a single global order of all
<code>SeqCst</code> operations (simplifies reasoning; can cost more).</p>
<p><strong>Example 1: A clean publish–subscribe in Rust (no <code>unsafe</code>)</strong></p>
<p>This example uses only atomics, so it stays fully safe. It shows the shape of
the pattern:</p>
<pre data-lang="rust" class="language-rust z-code"><code class="language-rust" data-lang="rust"><span class="z-source z-rust"><span class="z-keyword z-other z-rust">use</span> <span class="z-meta z-path z-rust">std<span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-meta z-path z-rust">sync<span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-meta z-path z-rust">atomic<span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>AtomicBool<span class="z-punctuation z-separator z-rust">,</span> AtomicUsize<span class="z-punctuation z-separator z-rust">,</span> Ordering</span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust"><span class="z-keyword z-other z-rust">use</span> <span class="z-meta z-path z-rust">std<span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-meta z-path z-rust">sync<span class="z-punctuation z-accessor z-rust">::</span></span>Arc<span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust"><span class="z-keyword z-other z-rust">use</span> <span class="z-meta z-path z-rust">std<span class="z-punctuation z-accessor z-rust">::</span></span>thread<span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-storage z-type z-struct z-rust">struct</span> </span><span class="z-meta z-struct z-rust"><span class="z-entity z-name z-struct z-rust">Shared</span> </span><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-other z-member z-rust">data</span><span class="z-punctuation z-separator z-type z-rust">:</span> AtomicUsize,
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-other z-member z-rust">ready</span><span class="z-punctuation z-separator z-type z-rust">:</span> AtomicBool,
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-function z-rust"><span class="z-storage z-type z-function z-rust">fn</span> </span><span class="z-entity z-name z-function z-rust">main</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-begin z-rust">(</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-end z-rust">)</span></span></span></span><span class="z-meta z-function z-rust"> </span><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">    <span class="z-storage z-type z-rust">let</span> s <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-meta z-path z-rust">Arc<span class="z-punctuation z-accessor z-rust">::</span></span>new<span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>Shared <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-group z-rust"><span class="z-meta z-block z-rust">        data<span class="z-punctuation z-separator z-rust">:</span> <span class="z-meta z-path z-rust">AtomicUsize<span class="z-punctuation z-accessor z-rust">::</span></span>new<span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-constant z-numeric z-integer z-decimal z-rust">0</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-separator z-rust">,</span>
</span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-group z-rust"><span class="z-meta z-block z-rust">        ready<span class="z-punctuation z-separator z-rust">:</span> <span class="z-meta z-path z-rust">AtomicBool<span class="z-punctuation z-accessor z-rust">::</span></span>new<span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-constant z-language z-rust">false</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-separator z-rust">,</span>
</span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-group z-rust"><span class="z-meta z-block z-rust">    </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">    <span class="z-storage z-type z-rust">let</span> t1 <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">        <span class="z-storage z-type z-rust">let</span> s <span class="z-keyword z-operator z-assignment z-rust">=</span> s<span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">clone</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">        <span class="z-meta z-path z-rust">thread<span class="z-punctuation z-accessor z-rust">::</span></span>spawn<span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-storage z-modifier z-rust">move</span> <span class="z-keyword z-operator z-logical z-rust">||</span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-group z-rust"><span class="z-meta z-block z-rust">            s<span class="z-punctuation z-accessor z-dot z-rust">.</span>data<span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">store</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-constant z-numeric z-integer z-decimal z-rust">42</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-meta z-path z-rust">Ordering<span class="z-punctuation z-accessor z-rust">::</span></span>Relaxed</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-group z-rust"><span class="z-meta z-block z-rust">            s<span class="z-punctuation z-accessor z-dot z-rust">.</span>ready<span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">store</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-constant z-language z-rust">true</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-meta z-path z-rust">Ordering<span class="z-punctuation z-accessor z-rust">::</span></span>Release</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-group z-rust"><span class="z-meta z-block z-rust">        </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">    </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">    <span class="z-storage z-type z-rust">let</span> t2 <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">        <span class="z-storage z-type z-rust">let</span> s <span class="z-keyword z-operator z-assignment z-rust">=</span> s<span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">clone</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">        <span class="z-meta z-path z-rust">thread<span class="z-punctuation z-accessor z-rust">::</span></span>spawn<span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-storage z-modifier z-rust">move</span> <span class="z-keyword z-operator z-logical z-rust">||</span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-group z-rust"><span class="z-meta z-block z-rust">            <span class="z-keyword z-control z-rust">while</span> <span class="z-keyword z-operator z-logical z-rust">!</span>s<span class="z-punctuation z-accessor z-dot z-rust">.</span>ready<span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">load</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-path z-rust">Ordering<span class="z-punctuation z-accessor z-rust">::</span></span>Acquire</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span>
</span></span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-group z-rust"><span class="z-meta z-block z-rust">            <span class="z-storage z-type z-rust">let</span> v <span class="z-keyword z-operator z-assignment z-rust">=</span> s<span class="z-punctuation z-accessor z-dot z-rust">.</span>data<span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">load</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-path z-rust">Ordering<span class="z-punctuation z-accessor z-rust">::</span></span>Relaxed</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-group z-rust"><span class="z-meta z-block z-rust">            <span class="z-support z-macro z-rust">assert_eq!</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>v<span class="z-punctuation z-separator z-rust">,</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">42</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-group z-rust"><span class="z-meta z-block z-rust">        </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">    </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">    t1<span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">join</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">unwrap</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">    t2<span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">join</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-support z-function z-rust">unwrap</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span></code></pre>
<p>The Release store on ready ensures the prior write to data becomes visible
to any thread that sees <code>ready == true</code> via an <code>Acquire</code> load.
Where I usually go wrong: I make ready relaxed too, and then the reader can
observe the flag without observing the published data on some
platforms/optimizations, the exact <em>it depends</em> Russ warns about.</p>
<p><strong>Example 2: Acquire/Release is not global sequential consistency</strong></p>
<p>A spicy detail from the language-memory-model world: Acquire/Release does
not impose a single total order across different memory locations.
Russ Cox shows the store-buffering litmus test remains possible under
C++11 acquire/release atomics, even though it is disallowed under
sequentially consistent atomics.
That means: you can correctly synchronize publication on one atomic, and
still not get <em>whole-program sequential consistency</em> for free.
This is why SeqCst exists: sometimes you want fewer degrees of freedom for the
machine, because you want fewer degrees of freedom in your own head.</p>
<p><strong>The unsafe cliff: memory ordering is only half the story</strong></p>
<p>Memory model can <em>be</em> two different beasts:</p>
<ul>
<li>Concurrency ordering (atomics, fences, visibility)</li>
<li>Aliasing &amp; provenance (what references mean; what the optimizer may assume)</li>
</ul>
<p>Rust's aliasing rules are why <code>&amp;T</code> implies <em>not being mutated</em> and <code>&amp;mut T</code>
implies <em>unique</em>. When you build interior mutability (like Cell, RefCell, Mutex),
Rust requires you to go through <code>UnsafeCell&lt;T&gt;</code>, it’s the sanctioned escape
hatch.
Key point from the UnsafeCell docs:</p>
<ul>
<li><code>UnsafeCell</code> relaxes the immutability guarantee behind <code>&amp;T</code></li>
<li>but it does not make aliasing <code>&amp;mut</code> references okay (uniqueness is still
required).</li>
</ul>
<p>Researchers and the Rust unsafe-code community have proposed operational models
like Stacked Borrows and Tree Borrows to formalize which pointer uses are allowed
and which become UB.</p>
<p>If you write unsafe abstractions, this is the layer that decides whether your code
is <em>works on my machine</em> or <em>silently illegal</em>.</p>
<p><strong>How to build confidence: Loom + Miri</strong></p>
<p>Loom is a concurrency testing tool that repeatedly runs your test while exploring
possible thread schedules under the C11-style memory model used for Rust atomics
in practice.</p>
<ul>
<li>Great for: custom mutexes, channels, lock-free structures, tricky state machines.</li>
<li>Not great for: <em>just add Loom to everything</em> (it’s targeted, and can explode in complexity).</li>
</ul>
<p>Miri interprets Rust and detects many classes of UB (out-of-bounds, use-after-free,
invalid aliasing patterns, etc.).</p>
<p>If your project has unsafe, running cargo miri test is a very direct <em>are we lying
to the compiler?</em> check.</p>
<p><strong>A tiny ordering cheat-sheet</strong></p>
<p>Just sharing read-only data across threads</p>
<ul>
<li>Prefer: Arc<T> + immutable data.</li>
<li>No atomics needed.</li>
</ul>
<p>Shared mutable state</p>
<ul>
<li>Prefer: Mutex, RwLock, channels (higher-level synchronization).</li>
<li>Atomics only when you’re building primitives or chasing specific
perf needs.</li>
</ul>
<p>Counters / metrics</p>
<ul>
<li>Often: Relaxed.</li>
</ul>
<p>Publish–subscribe / “ready flag”</p>
<ul>
<li>Writer: Release store</li>
<li>Reader: Acquire load</li>
</ul>
<p>You want the simplest reasoning model</p>
<ul>
<li>Use: SeqCst (until profiling proves you need weaker).</li>
</ul>
<p>The hardware wants speed. The compiler wants freedom. Our job is to
write down the constraints that make your program actually mean what
you think it means.</p>
<p>Rust helps by making <em>accidentally racy</em> code hard to express, and by
giving you the same atomic tools used to build the rest of the ecosystem.
The cost is that when you go low-level, you're now negotiating with three
contracts at once: CPU, compiler, and Rust's own rules.</p>

  </pre>
</main>

  
<script src="/js/lightense.min.js"></script>

  <script src="https://idunnowhatiamdoing.engineering/js/main.js"></script>
</body>

</html>
